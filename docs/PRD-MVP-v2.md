# PRD - Product Requirements Document
## MVP v2.0 - Transfer√™ncias, Saques e Administra√ß√£o

**Vers√£o:** 2.0
**Data:** 21 de Outubro de 2025
**Status:** Planejamento
**Autor:** Equipe de Desenvolvimento

---

## üìã √çndice

1. [Vis√£o Geral](#vis√£o-geral)
2. [O que foi entregue no v1.0](#o-que-foi-entregue-no-v10)
3. [Objetivos do v2.0](#objetivos-do-v20)
4. [Funcionalidades v2.0](#funcionalidades-v20)
5. [Fora do Escopo v2.0](#fora-do-escopo-v20)
6. [Especifica√ß√µes T√©cnicas](#especifica√ß√µes-t√©cnicas)

---

## üéØ Vis√£o Geral

O MVP v2.0 completa o ciclo financeiro do sistema, implementando transfer√™ncias em lote, sistema de saques, e ferramentas administrativas para gerenciar a plataforma.

### Problema a Resolver

Com o v1.0, usu√°rios podem:
- ‚úÖ Criar conta e fazer login
- ‚úÖ Receber endere√ßo de dep√≥sito
- ‚úÖ Fazer dep√≥sitos (qualquer token)
- ‚úÖ Ver saldo e transa√ß√µes

**Mas n√£o podem:**
- ‚ùå Sacar fundos
- ‚ùå Admins n√£o t√™m controle sobre transfer√™ncias
- ‚ùå Tokens ficam espalhados em m√∫ltiplos endere√ßos (alto custo de gas)

---

## ‚úÖ O que foi entregue no v1.0

### Funcionalidades Implementadas
1. **Autentica√ß√£o** - Better Auth (email/password)
2. **Sistema de Conta Virtual** - Status INACTIVE ‚Üí ACTIVE
3. **Ativa√ß√£o Autom√°tica** - Ap√≥s dep√≥sito >= $100 USD
4. **Endere√ßo Fixo Polygon** - 1 por usu√°rio, permanente
5. **Detec√ß√£o de Dep√≥sitos** - Webhook Moralis (qualquer token)
6. **Convers√£o de Pre√ßos** - CoinGecko API (tokens ‚Üí USD)
7. **Gest√£o de Saldo** - Multi-token, calculado em tempo real
8. **Hist√≥rico de Transa√ß√µes** - Completo por usu√°rio

### Banco de Dados v1.0
- ‚úÖ User (autentica√ß√£o + conta)
- ‚úÖ DepositAddress (1 por usu√°rio)
- ‚úÖ WalletTransaction (hist√≥rico)
- ‚úÖ GlobalWallet (criado mas n√£o usado)

### Status Atual
- Tokens ficam nos endere√ßos individuais dos usu√°rios
- Global Wallet existe mas n√£o recebe fundos
- Sistema preparado para pr√≥xima fase

---

## üéØ Objetivos do v2.0

### Objetivos de Neg√≥cio
1. Permitir que usu√°rios saquem seus fundos
2. Centralizar fundos na Global Wallet (reduzir custo de gas)
3. Dar aos admins controle sobre o fluxo financeiro
4. Preparar infraestrutura para MLM (fase 3)

### Objetivos T√©cnicos
1. ‚úÖ Implementar job/rota de transfer√™ncia em lote
2. ‚úÖ Implementar sistema completo de saques
3. ‚úÖ Criar painel administrativo b√°sico
4. ‚úÖ Otimizar custos de gas com batch transfers
5. ‚úÖ Adicionar rate limiting e seguran√ßa

---

## üì¶ Funcionalidades v2.0

### F1: Transfer√™ncia em Lote para Global Wallet

**Descri√ß√£o:** Rota administrativa que transfere todos os tokens de todos os endere√ßos de usu√°rios para a Global Wallet em uma √∫nica opera√ß√£o em lote.

**Crit√©rios de Aceita√ß√£o:**
- ‚úÖ Rota protegida por autentica√ß√£o de admin
- ‚úÖ Busca todos os endere√ßos com saldo > 0
- ‚úÖ **Fase 1:** Distribui MATIC da global para endere√ßos que precisam
- ‚úÖ **Fase 2:** Transfere todos os tokens ‚Üí global
- ‚úÖ **Fase 3:** Recupera MATIC que sobrou
- ‚úÖ Atualiza status das transa√ß√µes para `SENT_TO_GLOBAL`
- ‚úÖ Registra hash de cada transfer√™ncia
- ‚úÖ Tratamento robusto de erros (retry, logging)
- ‚úÖ Endpoint retorna relat√≥rio detalhado da opera√ß√£o

**Endpoints:**
```
POST /admin/transfers/batch-collect
Authorization: Bearer <admin-token>

Response:
{
  "success": true,
  "summary": {
    "totalAddresses": 25,
    "maticDistributed": "1.25",
    "tokensTransferred": {
      "USDC": "5000.00",
      "USDT": "2500.00",
      "MATIC": "500.00"
    },
    "maticRecovered": "0.85",
    "totalGasCost": "0.45 MATIC",
    "transactionsUpdated": 73
  },
  "details": [...],
  "errors": [...]
}
```

**Regras de Neg√≥cio:**
- Apenas admins podem executar
- Verifica se global wallet tem MATIC suficiente antes de iniciar (m√≠nimo 5 MATIC)
- **MATIC s√≥ √© enviado para endere√ßos que T√äM tokens ERC20** (USDC, USDT, etc)
- Endere√ßos com apenas MATIC nativo N√ÉO recebem MATIC (n√£o precisam de gas ERC20)
- Verifica MATIC existente antes de enviar (economiza gas)
- Deixa 0.001 MATIC de reserva em cada endere√ßo
- Se falhar em algum endere√ßo, continua com os pr√≥ximos
- Log completo de cada opera√ß√£o em `AdminLog`
- Pode ser executado manualmente ou via cron (futuro)

---

### F2: Sistema de Saques

**Descri√ß√£o:** Usu√°rios podem solicitar saque de seus fundos. Admin aprova e sistema processa automaticamente.

**Crit√©rios de Aceita√ß√£o:**
- ‚úÖ Usu√°rio pode solicitar saque (especificar token, valor, endere√ßo destino)
- ‚úÖ Valida√ß√µes: saldo suficiente, endere√ßo v√°lido, valor m√≠nimo
- ‚úÖ Saque fica com status `PENDING_APPROVAL`
- ‚úÖ Admin pode aprovar ou rejeitar
- ‚úÖ **Ap√≥s aprova√ß√£o, usu√°rio recebe notifica√ß√£o de autoriza√ß√£o**
- ‚úÖ Sistema transfere da Global Wallet ‚Üí endere√ßo do usu√°rio
- ‚úÖ **Usu√°rio recebe notifica√ß√£o de conclus√£o (com txHash)**
- ‚úÖ **Se rejeitado, usu√°rio recebe notifica√ß√£o com motivo**
- ‚úÖ Atualiza saldo do usu√°rio
- ‚úÖ Registra hash da transa√ß√£o

**Endpoints:**
```
# Usu√°rio solicita saque
POST /user/withdrawals/request
{
  "tokenSymbol": "USDC",
  "amount": "500.00",
  "destinationAddress": "0x..."
}

# Usu√°rio lista seus saques
GET /user/withdrawals

# Usu√°rio consulta notifica√ß√µes de saque
GET /user/withdrawals/:id/status

# Admin lista todos os saques pendentes
GET /admin/withdrawals?status=PENDING_APPROVAL

# Admin aprova saque (envia notifica√ß√£o ao usu√°rio)
POST /admin/withdrawals/:id/approve
Response:
{
  "success": true,
  "withdrawal": {...},
  "notificationSent": true,
  "message": "Withdrawal approved and user notified"
}

# Admin rejeita saque (envia notifica√ß√£o ao usu√°rio)
POST /admin/withdrawals/:id/reject
{
  "reason": "Saldo insuficiente"
}
Response:
{
  "success": true,
  "withdrawal": {...},
  "notificationSent": true,
  "message": "Withdrawal rejected and user notified"
}

# Admin retenta saque que falhou (apenas erros recuper√°veis)
POST /admin/withdrawals/:id/retry
Response:
{
  "success": true,
  "withdrawalId": "uuid",
  "message": "Withdrawal retry initiated"
}
```

**Regras de Neg√≥cio:**
- **Saque m√≠nimo: $500 USD**
- Taxa de saque: configur√°vel (ex: $5 fixo ou 1%)
- Verifica se global wallet tem saldo suficiente
- Apenas 1 saque pendente por vez por usu√°rio
- Ap√≥s aprova√ß√£o, processamento autom√°tico
- **Sistema de Retry para Falhas:**
  - Erros RECUPER√ÅVEIS (sem gas, sem saldo): saldo fica locked, admin pode retry
  - Erros PERMANENTES (endere√ßo inv√°lido): saldo devolvido automaticamente
  - Apenas saques FAILED podem ser retried
- Usu√°rio n√£o pode cancelar ap√≥s aprova√ß√£o

---

### F3: Dashboard Administrativo

**Descri√ß√£o:** Painel web simples para admins gerenciarem a plataforma.

**Crit√©rios de Aceita√ß√£o:**
- ‚úÖ Login de admin separado (role-based)
- ‚úÖ Estat√≠sticas gerais (total usu√°rios, dep√≥sitos, saques)
- ‚úÖ Lista de usu√°rios (com filtros e busca)
- ‚úÖ Detalhes de cada usu√°rio (saldo, transa√ß√µes, status)
- ‚úÖ Gest√£o de saques (aprovar/rejeitar)
- ‚úÖ Executar batch transfer
- ‚úÖ Ver saldo da Global Wallet
- ‚úÖ Logs de opera√ß√µes cr√≠ticas

**Endpoints:**
```
# Estat√≠sticas
GET /admin/stats

# Usu√°rios
GET /admin/users?page=1&limit=20&search=email

# Detalhes de usu√°rio
GET /admin/users/:id

# Bloquear/desbloquear usu√°rio
POST /admin/users/:id/block
POST /admin/users/:id/unblock

# Global Wallet
GET /admin/wallet/balance
GET /admin/wallet/transactions

# Logs
GET /admin/logs?type=TRANSFER&date=2025-10-21
```

**Regras de Neg√≥cio:**
- Apenas usu√°rios com `role: ADMIN` podem acessar
- Logs de todas as a√ß√µes de admin
- N√£o pode deletar usu√°rios (apenas bloquear)
- Dashboard pode ser React/Next.js (frontend separado) ou server-side rendered

---

### F4: Otimiza√ß√µes e Seguran√ßa

**Descri√ß√£o:** Melhorias de performance, seguran√ßa e monitoramento.

**Crit√©rios de Aceita√ß√£o:**

**Rate Limiting:**
- ‚úÖ 100 req/15min por IP em rotas p√∫blicas
- ‚úÖ 1000 req/15min em rotas autenticadas
- ‚úÖ 10 req/min em rotas de saque/transfer√™ncia

**Valida√ß√µes:**
- ‚úÖ Endere√ßo Polygon v√°lido (checksum)
- ‚úÖ Valor num√©rico positivo
- ‚úÖ Token suportado

**Monitoramento:**
- ‚úÖ Log estruturado (Pino/Winston)
- ‚úÖ M√©tricas de lat√™ncia
- ‚úÖ Alertas para erros cr√≠ticos
- ‚úÖ Health check endpoint

**Backup:**
- ‚úÖ Backup autom√°tico do banco
- ‚úÖ Backup das private keys (encrypted)

---

## ‚ùå Fora do Escopo v2.0

### Funcionalidades para v3.0+
- ‚ùå Sistema MLM (comiss√µes, indica√ß√µes, √°rvore geneal√≥gica)
- ‚ùå Notifica√ß√µes push/email
- ‚ùå Suporte a m√∫ltiplas blockchains
- ‚ùå Exchange interno (swap de tokens)
- ‚ùå Staking/Rendimentos
- ‚ùå App mobile (React Native)

---

## üîß Especifica√ß√µes T√©cnicas

### Novos Models Prisma

```prisma
enum WithdrawalStatus {
  PENDING_APPROVAL
  APPROVED
  PROCESSING
  COMPLETED
  REJECTED
  FAILED
}

model Withdrawal {
  id                  String           @id @default(uuid())
  userId              String
  tokenSymbol         String
  tokenAddress        String?
  amount              Decimal          @db.Decimal(20, 8)
  destinationAddress  String
  fee                 Decimal          @db.Decimal(20, 8)
  status              WithdrawalStatus @default(PENDING_APPROVAL)
  txHash              String?          @unique
  approvedBy          String?          // Admin userId
  approvedAt          DateTime?
  rejectedReason      String?
  processedAt         DateTime?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("withdrawals")
}

model AdminLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String   // "APPROVE_WITHDRAWAL", "BATCH_TRANSFER", etc
  entityId  String?  // ID do withdrawal, user, etc
  details   Json?    // Detalhes adicionais
  createdAt DateTime @default(now())

  @@map("admin_logs")
}

enum NotificationType {
  WITHDRAWAL_APPROVED
  WITHDRAWAL_REJECTED
  WITHDRAWAL_COMPLETED
  WITHDRAWAL_FAILED
}

model WithdrawalNotification {
  id           String           @id @default(uuid())
  userId       String
  withdrawalId String
  type         NotificationType
  title        String           // "Saque Aprovado!"
  message      String           // "Seu saque de 500 USDC foi aprovado pelo administrador"
  data         Json?            // Dados adicionais (txHash, motivo rejei√ß√£o, etc)
  read         Boolean          @default(false)
  createdAt    DateTime         @default(now())

  user       User       @relation(fields: [userId], references: [id])
  withdrawal Withdrawal @relation(fields: [withdrawalId], references: [id])

  @@index([userId, read]) // Para query de notifica√ß√µes n√£o lidas
  @@map("withdrawal_notifications")
}

// Adicionar ao User model:
model User {
  // ... campos existentes ...
  role      String   @default("user") // "user" ou "admin" (Better Auth j√° suporta)

  withdrawals              Withdrawal[]
  withdrawalNotifications  WithdrawalNotification[]
}

// Adicionar ao Withdrawal model:
model Withdrawal {
  // ... campos existentes ...
  notifications WithdrawalNotification[]
}
```

---

### Arquitetura de Saldo: Balance vs WalletTransaction

**Decis√£o Arquitetural:** A partir do v2.0, implementamos uma tabela separada `Balance` para armazenar saldos, mantendo `WalletTransaction` apenas como hist√≥rico/auditoria.

#### Problema com Arquitetura Atual (v1.0)

No v1.0, o saldo √© calculado dinamicamente a cada consulta:

```typescript
// GET /user/balance ‚Üí SELECT todas transactions ‚Üí SUM por token
const transactions = await prisma.walletTransaction.findMany({
  where: { userId, status: { in: ["CONFIRMED", "SENT_TO_GLOBAL"] } }
});

// Agrupa e soma (O(n) a cada consulta)
for (const tx of transactions) {
  if (tx.type === "CREDIT") balance += tx.amount;
  else balance -= tx.amount;
}
```

**Problemas:**
1. ‚ùå **Performance** - Query pesada a cada consulta de saldo
2. ‚ùå **Escala mal** - 1000 transa√ß√µes = 1000 rows para somar
3. ‚ùå **Valida√ß√£o complexa** - Dif√≠cil prevenir saldo negativo
4. ‚ùå **Race conditions** - Valida√ß√£o de saque pode ter conflitos
5. ‚ùå **Sem locking natural** - Precisa implementar manualmente

#### Nova Arquitetura (v2.0)

**Balance Model:**

```prisma
model Balance {
  id               String   @id @default(uuid())
  userId           String
  tokenSymbol      String
  tokenAddress     String?
  availableBalance Decimal  @db.Decimal(20, 8) // Saldo dispon√≠vel
  lockedBalance    Decimal  @db.Decimal(20, 8) @default(0) // Saques pendentes
  updatedAt        DateTime @updatedAt
  createdAt        DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tokenSymbol])
  @@index([userId])
  @@map("user_balances")
}

// Adicionar ao User model:
model User {
  // ... campos existentes ...
  balances Balance[]
}
```

**Vantagens:**
1. ‚úÖ **Performance** - Saldo j√° calculado (SELECT direto)
2. ‚úÖ **Valida√ß√£o simples** - `WHERE availableBalance >= amount`
3. ‚úÖ **Row-level locking** - PostgreSQL impede conflitos automaticamente
4. ‚úÖ **Saldo bloqueado** - Saques pendentes "reservam" valor
5. ‚úÖ **Auditoria preservada** - WalletTransaction continua existindo

#### Sincroniza√ß√£o: Transaction ‚Üí Balance

**Toda opera√ß√£o que cria transa√ß√£o DEVE atualizar saldo atomicamente:**

```typescript
// Dep√≥sito confirmado
await prisma.$transaction([
  // 1. Cria transa√ß√£o (hist√≥rico)
  prisma.walletTransaction.create({
    data: {
      userId,
      type: "CREDIT",
      amount: 100,
      tokenSymbol: "USDC",
      status: "CONFIRMED",
      ...
    }
  }),

  // 2. Atualiza saldo (upsert = cria se n√£o existir)
  prisma.balance.upsert({
    where: {
      userId_tokenSymbol: { userId, tokenSymbol: "USDC" }
    },
    create: {
      userId,
      tokenSymbol: "USDC",
      availableBalance: 100,
      lockedBalance: 0
    },
    update: {
      availableBalance: { increment: 100 }
    }
  })
]);
```

**Saque solicitado (reserva saldo):**

```typescript
await prisma.$transaction([
  // 1. Cria withdrawal
  prisma.withdrawal.create({
    data: { userId, amount: 50, tokenSymbol: "USDC", ... }
  }),

  // 2. Move de available ‚Üí locked
  prisma.balance.update({
    where: { userId_tokenSymbol: { userId, tokenSymbol: "USDC" } },
    data: {
      availableBalance: { decrement: 50 },
      lockedBalance: { increment: 50 }
    }
  })
]);
```

**Saque aprovado e processado:**

```typescript
await prisma.$transaction([
  // 1. Cria transa√ß√£o DEBIT (hist√≥rico)
  prisma.walletTransaction.create({
    data: {
      userId,
      type: "DEBIT",
      amount: 50,
      tokenSymbol: "USDC",
      status: "CONFIRMED",
      txHash: blockchainTxHash
    }
  }),

  // 2. Remove de locked (saldo j√° foi decrementado quando solicitou)
  prisma.balance.update({
    where: { userId_tokenSymbol: { userId, tokenSymbol: "USDC" } },
    data: {
      lockedBalance: { decrement: 50 }
    }
  }),

  // 3. Atualiza withdrawal
  prisma.withdrawal.update({
    where: { id: withdrawalId },
    data: { status: "COMPLETED", txHash: blockchainTxHash }
  })
]);
```

**Saque rejeitado (devolve saldo):**

```typescript
await prisma.$transaction([
  prisma.withdrawal.update({
    where: { id: withdrawalId },
    data: { status: "REJECTED", rejectedReason: "..." }
  }),

  // Devolve locked ‚Üí available
  prisma.balance.update({
    where: { userId_tokenSymbol: { userId, tokenSymbol } },
    data: {
      availableBalance: { increment: amount },
      lockedBalance: { decrement: amount }
    }
  })
]);
```

#### Valida√ß√µes com Balance

**Prevenir saldo negativo:**

```typescript
// Antes de criar withdrawal
const balance = await prisma.balance.findUnique({
  where: { userId_tokenSymbol: { userId, tokenSymbol } }
});

if (!balance || balance.availableBalance.lt(amount)) {
  throw new Error("INSUFFICIENT_BALANCE");
}

// Atomicamente no transaction:
const updated = await tx.userBalance.updateMany({
  where: {
    userId_tokenSymbol: { userId, tokenSymbol },
    availableBalance: { gte: amount } // S√≥ atualiza se tiver saldo
  },
  data: {
    availableBalance: { decrement: amount },
    lockedBalance: { increment: amount }
  }
});

if (updated.count === 0) {
  throw new Error("INSUFFICIENT_BALANCE"); // Race condition evitada!
}
```

#### GET /user/balance (v2.0)

**Novo endpoint otimizado:**

```typescript
// SELECT direto na tabela user_balances
const balances = await prisma.balance.findMany({
  where: { userId },
  select: {
    tokenSymbol: true,
    tokenAddress: true,
    availableBalance: true,
    lockedBalance: true
  }
});

// Calcula total USD
const totalUSD = await calculateTotalUSD(balances);

return {
  balances: balances.map(b => ({
    tokenSymbol: b.tokenSymbol,
    available: b.availableBalance,
    locked: b.lockedBalance,
    total: b.availableBalance.add(b.lockedBalance)
  })),
  totalUSD
};
```

**Response:**

```json
{
  "balances": [
    {
      "tokenSymbol": "USDC",
      "available": "100.00",
      "locked": "50.00",
      "total": "150.00"
    },
    {
      "tokenSymbol": "MATIC",
      "available": "25.50",
      "locked": "0.00",
      "total": "25.50"
    }
  ],
  "totalUSD": 175.50
}
```

#### Auditoria e Reconcilia√ß√£o

**WalletTransaction continua sendo source of truth para auditoria:**

```typescript
// Script de reconcilia√ß√£o (rodar periodicamente)
async function reconcileBalances() {
  const users = await prisma.user.findMany();

  for (const user of users) {
    // Calcula saldo "verdadeiro" das transa√ß√µes
    const transactions = await prisma.walletTransaction.findMany({
      where: { userId: user.id }
    });

    const calculatedBalance = transactions.reduce((acc, tx) => {
      if (tx.type === "CREDIT") return acc.add(tx.amount);
      else return acc.sub(tx.amount);
    }, new Decimal(0));

    // Compara com Balance
    const storedBalance = await prisma.balance.findUnique({
      where: { userId_tokenSymbol: { userId: user.id, tokenSymbol: "USDC" } }
    });

    const total = storedBalance.availableBalance.add(storedBalance.lockedBalance);

    if (!total.equals(calculatedBalance)) {
      console.error(`‚ö†Ô∏è  DESYNC: User ${user.id} - Expected ${calculatedBalance}, Got ${total}`);
      // Alertar admins, investigar
    }
  }
}
```

#### Migration para v2.0

**Passo 1: Criar tabela Balance**

```bash
npx prisma migrate dev --name add_user_balance
```

**Passo 2: Popular com saldos existentes**

```typescript
// scripts/migrate-to-user-balance.ts
async function migrateBalances() {
  const users = await prisma.user.findMany();

  for (const user of users) {
    const transactions = await prisma.walletTransaction.findMany({
      where: {
        userId: user.id,
        status: { in: ["CONFIRMED", "SENT_TO_GLOBAL"] }
      }
    });

    // Agrupa por token
    const balances = new Map<string, Decimal>();
    for (const tx of transactions) {
      const current = balances.get(tx.tokenSymbol) || new Decimal(0);
      if (tx.type === "CREDIT") {
        balances.set(tx.tokenSymbol, current.add(tx.amount));
      } else {
        balances.set(tx.tokenSymbol, current.sub(tx.amount));
      }
    }

    // Cria Balance
    for (const [tokenSymbol, balance] of balances) {
      await prisma.balance.create({
        data: {
          userId: user.id,
          tokenSymbol,
          availableBalance: balance,
          lockedBalance: 0
        }
      });
    }

    console.log(`‚úÖ Migrated balances for user ${user.id}`);
  }
}
```

**Passo 3: Atualizar c√≥digo**

- ‚úÖ Modificar `process-moralis-webhook.ts` para atualizar Balance
- ‚úÖ Modificar `get-user-balance.ts` para ler de Balance
- ‚úÖ Criar l√≥gica de withdrawal com locking
- ‚úÖ Adicionar reconcilia√ß√£o peri√≥dica

---

### Better Auth - Configura√ß√£o de Admin

**Descri√ß√£o:** Better Auth suporta roles nativamente. Vamos usar o campo `role` do User para diferenciar admins de usu√°rios comuns.

#### 1. Configura√ß√£o do Better Auth com Roles

```typescript
// src/lib/auth.ts
import { betterAuth } from "better-auth";
import { prismaAdapter } from "better-auth/adapters/prisma";
import { prisma } from "./prisma";

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: "postgresql",
  }),
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: false, // Mudar para true em produ√ß√£o
  },
  session: {
    expiresIn: 60 * 60 * 24 * 7, // 7 dias
    updateAge: 60 * 60 * 24, // Atualiza a cada 24h
    cookieCache: {
      enabled: true,
      maxAge: 5 * 60, // 5 minutos
    },
  },
  // Hook para adicionar role ao session
  async onSession(session) {
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: { role: true },
    });

    return {
      ...session,
      user: {
        ...session.user,
        role: user?.role || "user",
      },
    };
  },
});
```

#### 2. Middleware de Admin

**Arquivo:** `src/middlewares/admin.middleware.ts`

```typescript
import { FastifyRequest, FastifyReply } from "fastify";
import { auth } from "@/lib/auth";

/**
 * Middleware que verifica se o usu√°rio est√° autenticado E √© admin
 */
export async function requireAdmin(
  request: FastifyRequest,
  reply: FastifyReply
) {
  try {
    // Extrai session do cookie/header
    const session = await auth.api.getSession({
      headers: request.headers as any,
    });

    if (!session) {
      return reply.status(401).send({
        error: "UNAUTHORIZED",
        message: "Authentication required",
      });
    }

    // Busca usu√°rio completo do banco
    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        status: true,
      },
    });

    if (!user) {
      return reply.status(401).send({
        error: "USER_NOT_FOUND",
        message: "User not found",
      });
    }

    // Verifica se √© admin
    if (user.role !== "admin") {
      return reply.status(403).send({
        error: "FORBIDDEN",
        message: "Admin access required",
      });
    }

    // Verifica se admin est√° bloqueado
    if (user.status === "BLOCKED") {
      return reply.status(403).send({
        error: "ACCOUNT_BLOCKED",
        message: "Your admin account has been blocked",
      });
    }

    // Adiciona user completo no request para uso nos controllers
    request.user = user;
  } catch (error) {
    request.log.error({ error }, "Admin authentication error");
    return reply.status(401).send({
      error: "AUTHENTICATION_ERROR",
      message: "Failed to authenticate admin",
    });
  }
}
```

#### 3. Middleware de Autentica√ß√£o Normal (j√° existe)

**Arquivo:** `src/middlewares/auth.middleware.ts`

```typescript
import { FastifyRequest, FastifyReply } from "fastify";
import { auth } from "@/lib/auth";

/**
 * Middleware que verifica se o usu√°rio est√° autenticado (qualquer role)
 */
export async function requireAuth(
  request: FastifyRequest,
  reply: FastifyReply
) {
  try {
    const session = await auth.api.getSession({
      headers: request.headers as any,
    });

    if (!session) {
      return reply.status(401).send({
        error: "UNAUTHORIZED",
        message: "Authentication required",
      });
    }

    const user = await prisma.user.findUnique({
      where: { id: session.user.id },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        status: true,
      },
    });

    if (!user) {
      return reply.status(401).send({
        error: "USER_NOT_FOUND",
        message: "User not found",
      });
    }

    if (user.status === "BLOCKED") {
      return reply.status(403).send({
        error: "ACCOUNT_BLOCKED",
        message: "Your account has been blocked",
      });
    }

    request.user = user;
  } catch (error) {
    request.log.error({ error }, "Authentication error");
    return reply.status(401).send({
      error: "AUTHENTICATION_ERROR",
      message: "Failed to authenticate",
    });
  }
}
```

#### 4. Type Definitions para Request

**Arquivo:** `src/types/fastify.d.ts`

```typescript
import 'fastify';

declare module 'fastify' {
  interface FastifyRequest {
    user?: {
      id: string;
      email: string;
      name: string;
      role: string;
      status: string;
    };
  }
}
```

#### 5. Exemplo de Uso em Rotas Admin

**Arquivo:** `src/modules/admin/routes.ts`

```typescript
import { FastifyInstance } from "fastify";
import { requireAdmin } from "@/middlewares/admin.middleware";
import { getStatsController } from "./controllers/get-stats-controller";
import { listUsersController } from "./controllers/list-users-controller";
import { blockUserController } from "./controllers/block-user-controller";

export async function adminRoutes(app: FastifyInstance) {
  // TODAS as rotas admin usam o middleware requireAdmin
  app.addHook("onRequest", requireAdmin);

  // Estat√≠sticas
  app.get("/stats", getStatsController);

  // Gest√£o de usu√°rios
  app.get("/users", listUsersController);
  app.get("/users/:id", getUserDetailsController);
  app.post("/users/:id/block", blockUserController);
  app.post("/users/:id/unblock", unblockUserController);

  // Saques
  app.get("/withdrawals", listAllWithdrawalsController);
  app.post("/withdrawals/:id/approve", approveWithdrawalController);
  app.post("/withdrawals/:id/reject", rejectWithdrawalController);

  // Transfers
  app.post("/transfers/batch-collect", batchCollectController);

  // Global Wallet
  app.get("/wallet/balance", getGlobalBalanceController);
  app.get("/wallet/transactions", getGlobalTransactionsController);

  // Logs
  app.get("/logs", getAdminLogsController);
}
```

#### 6. Exemplo de Controller Admin

**Arquivo:** `src/modules/admin/controllers/approve-withdrawal-controller.ts`

```typescript
import { FastifyRequest, FastifyReply } from "fastify";
import { z } from "zod";
import { approveWithdrawal } from "../use-cases/approve-withdrawal";

const paramsSchema = z.object({
  id: z.string().uuid(),
});

export async function approveWithdrawalController(
  request: FastifyRequest,
  reply: FastifyReply
) {
  try {
    // request.user j√° est√° dispon√≠vel gra√ßas ao middleware requireAdmin
    const adminId = request.user!.id; // Sabemos que existe por causa do middleware

    const { id: withdrawalId } = paramsSchema.parse(request.params);

    const result = await approveWithdrawal({
      withdrawalId,
      adminId, // Passa o ID do admin que aprovou
    });

    return reply.status(200).send({
      success: true,
      withdrawal: result.withdrawal,
      notificationSent: result.notificationSent,
      message: "Withdrawal approved and user notified",
    });
  } catch (error) {
    request.log.error({ error }, "Error approving withdrawal");

    if (error instanceof Error) {
      return reply.status(400).send({
        error: "APPROVAL_FAILED",
        message: error.message,
      });
    }

    return reply.status(500).send({
      error: "INTERNAL_ERROR",
      message: "Failed to approve withdrawal",
    });
  }
}
```

#### 7. Como Criar Administradores

**IMPORTANTE: Admins s√£o criados APENAS manualmente por seguran√ßa.**

N√£o existe rota de signup para admins. Eles devem ser criados diretamente no banco de dados.

**Fluxo de Cria√ß√£o:**

1. Usu√°rio cria conta normal via `/api/auth/sign-up` (frontend)
2. DBA/Desenvolvedor promove esse usu√°rio para admin

---

### Desenvolvimento

**Op√ß√£o 1: Seed Script (Recomendado - cria 4 admins)**

```bash
npx tsx prisma/seed-admins.ts
```

**Admins criados:**
- `alpha@admin.com` - Nome: Alpha - Senha: `Admin@2025`
- `bravo@admin.com` - Nome: Bravo - Senha: `Admin@2025`
- `charlie@admin.com` - Nome: Charlie - Senha: `Admin@2025`
- `delta@admin.com` - Nome: Delta - Senha: `Admin@2025`

‚ö†Ô∏è **Trocar senhas em produ√ß√£o!**

**Op√ß√£o 2: Prisma Studio (Permitido em dev)**

```bash
npx prisma studio
```

1. Navegue at√© a tabela `users`
2. Encontre o usu√°rio que ser√° admin
3. Edite o campo `role` de `"user"` para `"admin"`
4. Salve as mudan√ßas

**Op√ß√£o 3: SQL Direto via psql**

```bash
psql -U postgres -d mvppir
```

```sql
UPDATE users
SET role = 'admin', status = 'ACTIVE'
WHERE email = 'admin@example.com'
RETURNING id, email, role, status;
```

---

### Produ√ß√£o

**NUNCA use Prisma Studio em produ√ß√£o** (n√£o deve estar dispon√≠vel).

**M√©todo √öNICO: SQL Direto via SSH**

```bash
# 1. SSH no servidor de produ√ß√£o
ssh user@production-server

# 2. Conecta no banco PostgreSQL
psql $DATABASE_URL

# 3. Promove usu√°rio para admin
UPDATE users
SET role = 'admin', status = 'ACTIVE'
WHERE email = 'admin@empresa.com'
RETURNING id, email, role, status, "createdAt";

# 4. Verifica
SELECT id, email, role, status FROM users WHERE role = 'admin';

# 5. Sai
\q
```

**Alternativa: Cliente PostgreSQL Remoto**

Use **pgAdmin**, **DBeaver** ou **TablePlus** conectando remotamente no banco:

```sql
UPDATE users
SET role = 'admin', status = 'ACTIVE'
WHERE email = 'admin@empresa.com'
RETURNING id, email, role, status;
```

---

### Regras de Seguran√ßa

- ‚ùå **N√ÉO** criar rota `/api/auth/admin-signup`
- ‚ùå **N√ÉO** permitir auto-promo√ß√£o via API
- ‚ùå **N√ÉO** expor Prisma Studio em produ√ß√£o
- ‚úÖ Apenas DBAs/Desenvolvedores podem criar admins
- ‚úÖ Usar SQL direto em produ√ß√£o
- ‚úÖ Documentar quem criou cada admin (logs SSH)
- ‚úÖ Sempre usar `RETURNING` para confirmar opera√ß√£o
- üí° Email n√£o precisa existir/ser v√°lido (√© apenas identificador)

---

### Scripts √öteis

**Listar todos os admins:**

```sql
SELECT
  id,
  email,
  name,
  role,
  status,
  "createdAt",
  "activatedAt"
FROM users
WHERE role = 'admin'
ORDER BY "createdAt" DESC;
```

**Remover permiss√£o de admin (rebaixar para user):**

```sql
UPDATE users
SET role = 'user'
WHERE email = 'ex-admin@example.com'
RETURNING id, email, role;
```

---

### Implementa√ß√£o do Seeder de Admins

**Arquivo:** `prisma/seed-admins.ts`

Cria 4 admins com codinomes @admin.com para desenvolvimento.

```typescript
import { PrismaClient } from "@prisma/client";
import { hash } from "bcrypt";

const prisma = new PrismaClient();

const ADMIN_ACCOUNTS = [
  { email: "alpha@admin.com", name: "Alpha" },
  { email: "bravo@admin.com", name: "Bravo" },
  { email: "charlie@admin.com", name: "Charlie" },
  { email: "delta@admin.com", name: "Delta" },
];

const DEFAULT_PASSWORD = "Admin@2025";

async function main() {
  console.log("üîê Creating admin accounts...\n");

  const hashedPassword = await hash(DEFAULT_PASSWORD, 10);

  for (const admin of ADMIN_ACCOUNTS) {
    const user = await prisma.user.upsert({
      where: { email: admin.email },
      update: {},
      create: {
        email: admin.email,
        name: admin.name,
        role: "admin",
        status: "ACTIVE",
        emailVerified: true,
        accounts: {
          create: {
            accountId: `${admin.name.toLowerCase()}-account`,
            providerId: "credential",
            password: hashedPassword,
          },
        },
      },
    });

    console.log(`‚úÖ ${admin.email} (${admin.name})`);
  }

  console.log("\nüéâ All admin accounts created!");
  console.log(`üìß Default password: ${DEFAULT_PASSWORD}`);
  console.log("‚ö†Ô∏è  Remember to change passwords in production!");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Executar:**

```bash
npx tsx prisma/seed-admins.ts
```

**Package.json script (opcional):**

```json
{
  "scripts": {
    "seed:admins": "tsx prisma/seed-admins.ts"
  }
}
```

Ent√£o pode rodar: `npm run seed:admins`

#### 8. Logging de A√ß√µes Admin

**Todas as a√ß√µes cr√≠ticas de admin devem ser logadas:**

```typescript
// src/lib/admin-logger.ts
import { prisma } from "./prisma";

export async function logAdminAction({
  adminId,
  action,
  entityId,
  details,
}: {
  adminId: string;
  action: string;
  entityId?: string;
  details?: Record<string, any>;
}) {
  await prisma.adminLog.create({
    data: {
      adminId,
      action,
      entityId,
      details: details ? JSON.parse(JSON.stringify(details)) : null,
    },
  });

  console.log(`üîí Admin Action: ${action} by ${adminId}`, {
    entityId,
    details,
  });
}
```

**Uso:**

```typescript
// Ap√≥s aprovar um saque
await logAdminAction({
  adminId: request.user.id,
  action: "APPROVE_WITHDRAWAL",
  entityId: withdrawalId,
  details: {
    amount: withdrawal.amount.toString(),
    tokenSymbol: withdrawal.tokenSymbol,
    userId: withdrawal.userId,
  },
});
```

#### 9. Prote√ß√£o Extra: Rate Limiting Admin

**Mesmo admins devem ter rate limiting:**

```typescript
// src/plugins/rate-limit.plugin.ts
import rateLimit from "@fastify/rate-limit";

export async function rateLimitPlugin(app: FastifyInstance) {
  await app.register(rateLimit, {
    max: 100, // Requisi√ß√µes
    timeWindow: '15 minutes',

    // Rate limit espec√≠fico para admins
    keyGenerator: (request) => {
      const user = request.user;
      if (user?.role === 'admin') {
        return `admin:${user.id}`;
      }
      return request.ip;
    },
  });
}
```

---

### Setup da Global Wallet (v2.0)

**Descri√ß√£o:** A Global Wallet √© a carteira central que recebe todos os tokens dos usu√°rios via batch transfers e processa os saques.

No v1.0, a Global Wallet existe no banco mas **n√£o √© usada**. No v2.0, ela se torna **cr√≠tica** para o sistema.

#### Por que precisamos da Global Wallet?

1. **Batch Transfers** - Centraliza fundos de m√∫ltiplos endere√ßos (reduz custo de gas)
2. **Withdrawals** - Processa saques de usu√°rios a partir de um √∫nico endere√ßo
3. **Liquidez** - Mant√©m saldo de MATIC para pagar gas das transfer√™ncias

#### Como Criar e Configurar

**Arquivo:** `scripts/create-global-wallet.ts`

Script helper que gera a wallet, encripta a private key e mostra como adicionar no `.env`.

```typescript
import { Wallet } from "ethers";
import { encryptPrivateKey } from "../src/lib/encryption";
import { prisma } from "../src/lib/prisma";

async function createGlobalWallet() {
  console.log("üîê Creating Global Wallet...\n");

  // 1. Gera wallet aleat√≥ria
  const wallet = Wallet.createRandom();

  console.log("‚úÖ Wallet generated!");
  console.log(`üìç Address: ${wallet.address}`);
  console.log(`üîë Private Key (RAW): ${wallet.privateKey}\n`);

  // 2. Encripta private key
  const encryptedPrivateKey = encryptPrivateKey(wallet.privateKey);

  console.log("üîí Private Key encrypted!");
  console.log(`üîê Encrypted: ${encryptedPrivateKey}\n`);

  // 3. Salva no banco de dados
  const globalWallet = await prisma.globalWallet.create({
    data: {
      polygonAddress: wallet.address.toLowerCase(),
      privateKey: encryptedPrivateKey,
    },
  });

  console.log("üíæ Global Wallet saved to database!");
  console.log(`üÜî Database ID: ${globalWallet.id}\n`);

  // 4. Instru√ß√µes finais
  console.log("‚úÖ Global Wallet configurada com sucesso!\n");

  console.log("üìã Pr√≥ximos passos:\n");
  console.log("1. Fund this address with MATIC for gas fees:");
  console.log(`   ${wallet.address}\n`);
  console.log("2. Recommended: 10-50 MATIC to start\n");

  console.log("üîê Seguran√ßa:");
  console.log("‚úÖ Private key armazenada ENCRIPTADA no banco");
  console.log("‚úÖ ENCRYPTION_KEY necess√°ria para descriptografar (est√° no .env)");
  console.log("‚úÖ Atacante precisa comprometer banco + .env\n");

  console.log("‚ö†Ô∏è  IMPORTANTE:");
  console.log("1. Backup do banco = backup da Global Wallet");
  console.log("2. NUNCA compartilhe a ENCRYPTION_KEY");
  console.log("3. Em produ√ß√£o, considere hardware wallet ou multi-sig\n");

  console.log("‚ú® Setup completo!");
}

createGlobalWallet()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

**Executar:**

```bash
npx tsx scripts/create-global-wallet.ts
```

**Sa√≠da esperada:**

```
üîê Creating Global Wallet...

‚úÖ Wallet generated!
üìç Address: 0x1234567890abcdef1234567890abcdef12345678
üîë Private Key (RAW): 0xabcdef...

üîí Private Key encrypted!
üîê Encrypted: U2FsdGVkX1...

üíæ Global Wallet saved to database!
üÜî Database ID: uuid-here

‚úÖ Global Wallet configurada com sucesso!

üìã Pr√≥ximos passos:

1. Fund this address with MATIC for gas fees:
   0x1234567890abcdef1234567890abcdef12345678

2. Recommended: 10-50 MATIC to start

üîê Seguran√ßa:
‚úÖ Private key armazenada ENCRIPTADA no banco
‚úÖ ENCRYPTION_KEY necess√°ria para descriptografar (est√° no .env)
‚úÖ Atacante precisa comprometer banco + .env

‚ö†Ô∏è  IMPORTANTE:
1. Backup do banco = backup da Global Wallet
2. NUNCA compartilhe a ENCRYPTION_KEY
3. Em produ√ß√£o, considere hardware wallet ou multi-sig

‚ú® Setup completo!
```

#### Funding da Global Wallet

Ap√≥s criar a Global Wallet, voc√™ **DEVE** enviar MATIC para ela:

```bash
# 1. Copie o endere√ßo da Global Wallet
echo $GLOBAL_WALLET_ADDRESS

# 2. Envie MATIC via MetaMask ou exchange
# Recomendado: 10-50 MATIC para come√ßar
```

**Por que precisa de MATIC?**
- Pagar gas das transfer√™ncias em lote
- Pagar gas dos saques de usu√°rios
- Sem MATIC = sistema travado ‚ö†Ô∏è

#### Verificar Saldo da Global Wallet

```typescript
// GET /admin/wallet/balance
{
  "address": "0x1234...",
  "balances": {
    "MATIC": "25.5",
    "USDC": "10000.00",
    "USDT": "5000.00"
  },
  "totalUSD": "15025.50"
}
```

#### Package.json script (opcional):

```json
{
  "scripts": {
    "setup:global-wallet": "tsx scripts/create-global-wallet.ts"
  }
}
```

#### Como Usar a Global Wallet no C√≥digo

**Buscar do banco e descriptografar quando necess√°rio:**

```typescript
// src/modules/wallet/use-cases/get-global-wallet.ts
import { prisma } from "@/lib/prisma";
import { decryptPrivateKey } from "@/lib/encryption";
import { Wallet, JsonRpcProvider } from "ethers";

export async function getGlobalWallet() {
  // 1. Busca do banco
  const globalWallet = await prisma.globalWallet.findFirst({
    orderBy: { createdAt: 'desc' }
  });

  if (!globalWallet) {
    throw new Error("Global Wallet not found in database");
  }

  // 2. Descriptografa private key
  const privateKey = decryptPrivateKey(globalWallet.privateKey);

  // 3. Cria inst√¢ncia do Wallet
  const provider = new JsonRpcProvider(process.env.POLYGON_RPC_URL);
  const wallet = new Wallet(privateKey, provider);

  return {
    address: globalWallet.polygonAddress,
    wallet, // Pronta para usar (enviar transa√ß√µes)
  };
}
```

**Exemplo de uso (batch transfer):**

```typescript
// src/modules/transfer/use-cases/batch-collect-to-global.ts
import { getGlobalWallet } from "@/modules/wallet/use-cases/get-global-wallet";

export async function batchCollectToGlobal() {
  // Obt√©m Global Wallet do banco
  const { wallet: globalWallet, address } = await getGlobalWallet();

  // Usa para enviar MATIC, processar saques, etc
  const tx = await globalWallet.sendTransaction({
    to: userAddress,
    value: parseEther("0.1"),
  });

  await tx.wait();
}
```

#### Seguran√ßa da Global Wallet

‚ö†Ô∏è **CR√çTICO: Esta wallet controla TODOS os fundos da plataforma!**

**Prote√ß√µes Implementadas:**
- ‚úÖ Private key **encriptada no banco** (AES-256-GCM)
- ‚úÖ ENCRYPTION_KEY separada no .env (seguran√ßa em camadas)
- ‚úÖ Atacante precisa comprometer **banco + .env**
- ‚úÖ Apenas admins podem ver saldo
- ‚úÖ Apenas admins podem executar transfers/withdrawals
- ‚úÖ Monitoramento 24/7 de transa√ß√µes suspeitas
- ‚úÖ Rate limiting em rotas de saque/transfer
- ‚úÖ Logs de todas as opera√ß√µes (AdminLog)
- ‚úÖ Backup autom√°tico do banco = backup da wallet

**Recomenda√ß√µes para Produ√ß√£o:**
- üîê Usar hardware wallet (Ledger/Trezor)
- üîê Multi-sig wallet (Gnosis Safe) para grandes volumes
- üîê Cold wallet para reservas (> $100k)
- üîê Hot wallet (Global Wallet) apenas com liquidez necess√°ria
- üîê Rota√ß√£o peri√≥dica da ENCRYPTION_KEY
- üîê Alertas autom√°ticos para movimenta√ß√µes grandes
- üîê Auditoria de seguran√ßa profissional

---

### Vari√°veis de Ambiente Adicionais

**IMPORTANTE:** A partir do v2.0, a Global Wallet private key √© armazenada **encriptada no banco**, n√£o mais no `.env`.

```env
# Saque
WITHDRAWAL_MIN_USD=500
WITHDRAWAL_FEE_USD=5
WITHDRAWAL_FEE_PERCENT=1

# Rate Limiting
RATE_LIMIT_PUBLIC=100
RATE_LIMIT_AUTHENTICATED=1000
RATE_LIMIT_CRITICAL=10

# Monitoring
SENTRY_DSN="https://..."
LOG_LEVEL=info

# NOTA: GLOBAL_WALLET_ADDRESS e GLOBAL_WALLET_PRIVATE_KEY foram REMOVIDAS
# Agora a Global Wallet √© armazenada no banco de dados (tabela global_wallets)
# Apenas a ENCRYPTION_KEY √© necess√°ria no .env para descriptografar
```

### Endpoints de Notifica√ß√£o

```
# Usu√°rio lista suas notifica√ß√µes
GET /user/notifications
Response:
{
  "notifications": [
    {
      "id": "uuid",
      "type": "WITHDRAWAL_APPROVED",
      "title": "Saque Aprovado!",
      "message": "Seu saque de 500 USDC foi aprovado",
      "data": { "withdrawalId": "uuid", "amount": "500" },
      "read": false,
      "createdAt": "2025-10-21T10:00:00Z"
    }
  ],
  "unreadCount": 3
}

# Marcar notifica√ß√£o como lida
PATCH /user/notifications/:id/read

# Marcar todas como lidas
PATCH /user/notifications/read-all
```

### Estrutura de M√≥dulos

```
src/modules/
‚îú‚îÄ admin/
‚îÇ  ‚îú‚îÄ controllers/
‚îÇ  ‚îÇ  ‚îú‚îÄ get-stats-controller.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ list-users-controller.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ get-user-details-controller.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ block-user-controller.ts
‚îÇ  ‚îú‚îÄ use-cases/
‚îÇ  ‚îÇ  ‚îú‚îÄ get-platform-stats.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ manage-user-status.ts
‚îÇ  ‚îî‚îÄ routes.ts
‚îÇ
‚îú‚îÄ transfer/
‚îÇ  ‚îú‚îÄ controllers/
‚îÇ  ‚îÇ  ‚îî‚îÄ batch-collect-controller.ts
‚îÇ  ‚îú‚îÄ use-cases/
‚îÇ  ‚îÇ  ‚îî‚îÄ batch-collect-to-global.ts
‚îÇ  ‚îî‚îÄ routes.ts
‚îÇ
‚îú‚îÄ withdrawal/
‚îÇ  ‚îú‚îÄ controllers/
‚îÇ  ‚îÇ  ‚îú‚îÄ request-withdrawal-controller.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ list-withdrawals-controller.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ approve-withdrawal-controller.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ reject-withdrawal-controller.ts
‚îÇ  ‚îú‚îÄ use-cases/
‚îÇ  ‚îÇ  ‚îú‚îÄ request-withdrawal.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ approve-withdrawal.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ process-withdrawal.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ reject-withdrawal.ts
‚îÇ  ‚îú‚îÄ services/
‚îÇ  ‚îÇ  ‚îî‚îÄ notification.service.ts  // Envia notifica√ß√µes
‚îÇ  ‚îî‚îÄ routes.ts
‚îÇ
‚îú‚îÄ notification/
‚îÇ  ‚îú‚îÄ controllers/
‚îÇ  ‚îÇ  ‚îú‚îÄ list-notifications-controller.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ mark-as-read-controller.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ mark-all-read-controller.ts
‚îÇ  ‚îú‚îÄ use-cases/
‚îÇ  ‚îÇ  ‚îú‚îÄ create-notification.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ get-user-notifications.ts
‚îÇ  ‚îî‚îÄ routes.ts
‚îÇ
‚îî‚îÄ wallet/
   ‚îú‚îÄ controllers/
   ‚îÇ  ‚îî‚îÄ get-global-balance-controller.ts
   ‚îú‚îÄ use-cases/
   ‚îÇ  ‚îú‚îÄ get-global-wallet-balance.ts
   ‚îÇ  ‚îî‚îÄ decrypt-private-key.ts
   ‚îî‚îÄ routes.ts
```

---

## üìä M√©tricas de Sucesso

### M√©tricas de Produto
- ‚úÖ 95% dos saques processados em < 10 minutos
- ‚úÖ 100% dos batch transfers bem-sucedidos
- ‚úÖ Redu√ß√£o de 80% no custo de gas vs transfer√™ncias individuais
- ‚úÖ 0 saques perdidos ou duplicados

### M√©tricas T√©cnicas
- ‚úÖ Admin dashboard load time < 2s
- ‚úÖ Withdrawal approval API < 500ms
- ‚úÖ Batch transfer completa em < 5min para 100 endere√ßos
- ‚úÖ 99.9% uptime

### M√©tricas de Seguran√ßa
- ‚úÖ 0 private keys expostas
- ‚úÖ 100% das a√ß√µes de admin logadas
- ‚úÖ Rate limiting efetivo (0 ataques bem-sucedidos)

---

## üö® Riscos e Mitiga√ß√µes

### Risco 1: Global Wallet Comprometida
**Impacto:** Cr√≠tico
**Probabilidade:** Baixa
**Mitiga√ß√£o:**
- Multi-sig wallet (fase futura)
- Monitoramento 24/7
- Limites di√°rios de saque
- Cold wallet para fundos maiores

### Risco 2: Falha no Batch Transfer
**Impacto:** Alto
**Probabilidade:** M√©dia
**Mitiga√ß√£o:**
- Retry autom√°tico (3 tentativas)
- Continuar mesmo se alguns falharem
- Alertas imediatos
- Rollback se > 50% falhar

### Risco 3: Saque Processado Duas Vezes
**Impacto:** Alto (perda financeira)
**Probabilidade:** Baixa
**Mitiga√ß√£o (Defense in Depth):**

**Camada 0: Aprova√ß√£o Manual por Admin (Linha de Frente)**
```typescript
// NENHUM saque √© processado automaticamente
// Fluxo obrigat√≥rio:
// 1. Usu√°rio solicita ‚Üí status: PENDING_APPROVAL
// 2. Admin revisa manualmente
// 3. Admin aprova ‚Üí status: APPROVED
// 4. Sistema processa ‚Üí status: PROCESSING ‚Üí COMPLETED

// Vantagens:
// - Humano verifica cada saque antes de processar
// - Admin pode validar: endere√ßo, valor, usu√°rio, hist√≥rico
// - Previne fraudes e erros
// - Admin v√™ se j√° foi processado antes de aprovar
```

**Camada 1: Lock Pessimista no Banco**
```typescript
// Usa SELECT FOR UPDATE para lock da linha
const withdrawal = await prisma.$transaction(async (tx) => {
  const w = await tx.withdrawal.findUnique({
    where: { id: withdrawalId },
    // Lock pessimista - impede leitura concorrente
  });

  // Verifica status - deve estar APPROVED
  if (w.status !== 'APPROVED') {
    throw new Error('Invalid status for processing');
  }

  // Atualiza para PROCESSING atomicamente
  return tx.withdrawal.update({
    where: { id: withdrawalId },
    data: {
      status: 'PROCESSING',
      processedAt: new Date()
    }
  });
}, {
  isolationLevel: 'Serializable' // M√°ximo n√≠vel de isolamento
});
```

**Camada 2: Status Intermedi√°rio**
- `APPROVED` ‚Üí `PROCESSING` ‚Üí `COMPLETED`
- Apenas saques com status `APPROVED` podem ser processados
- `PROCESSING` impede reprocessamento

**Camada 3: Verifica√ß√£o de txHash**
```typescript
// Antes de processar, verifica se j√° existe txHash
if (withdrawal.txHash) {
  throw new Error('Withdrawal already has txHash - already processed');
}

// Ap√≥s enviar transa√ß√£o blockchain
await prisma.withdrawal.update({
  where: { id: withdrawalId },
  data: {
    txHash: txHash,
    status: 'COMPLETED'
  }
});
```

**Camada 4: processedAt como Lock Natural**
```typescript
// Usa updateMany com WHERE para garantir atomicidade
// S√≥ atualiza se processedAt ainda for null
const updated = await tx.withdrawal.updateMany({
  where: {
    id: withdrawalId,
    status: 'APPROVED',
    processedAt: null,  // S√≥ se ainda n√£o foi processado
    txHash: null,
  },
  data: {
    status: 'PROCESSING',
    processedAt: new Date(),
  }
});

// Se count = 0, significa que j√° foi processado
if (updated.count === 0) {
  throw new Error('Withdrawal already processed or invalid status');
}

// Nenhuma tabela extra ou Redis necess√°rio!
// O campo processedAt j√° existe no model Withdrawal
```

**Camada 5: Unique Constraint no Banco**
```prisma
model Withdrawal {
  // ...
  txHash String? @unique // Garante que n√£o pode ter 2 saques com mesmo txHash
}
```

**Camada 6: Rate Limiting por Usu√°rio**
```typescript
// M√°ximo 1 saque em processamento por usu√°rio
const processing = await prisma.withdrawal.count({
  where: {
    userId: withdrawal.userId,
    status: 'PROCESSING'
  }
});

if (processing > 0) {
  throw new Error('User already has withdrawal being processed');
}
```

**Camada 7: Rastreabilidade - Qual Admin Autorizou**
```typescript
// Quando admin aprova o saque, registra quem autorizou
await prisma.withdrawal.update({
  where: { id: withdrawalId },
  data: {
    status: 'APPROVED',
    approvedBy: adminId,        // ‚Üê Registra qual admin aprovou
    approvedAt: new Date(),
  }
});

// Quando processa, verifica quem autorizou
const withdrawal = await prisma.withdrawal.findUnique({
  where: { id: withdrawalId },
  include: {
    user: true,  // Usu√°rio que solicitou
  }
});

// Log completo com rastreabilidade
await prisma.adminLog.create({
  data: {
    adminId: processingAdminId,    // Admin processando
    action: 'PROCESS_WITHDRAWAL',
    entityId: withdrawalId,
    details: {
      approvedBy: withdrawal.approvedBy,  // Admin que aprovou
      approvedAt: withdrawal.approvedAt,
      userId: withdrawal.userId,
      amount: withdrawal.amount.toString(),
      tokenSymbol: withdrawal.tokenSymbol,
    }
  }
});
```

**Camada 8: Auditoria e Alertas**
```typescript
// Alerta se detectar tentativa duplicada
if (isDuplicate) {
  await sendAlert({
    type: 'CRITICAL',
    message: `Duplicate withdrawal processing attempt: ${withdrawalId}`,
    approvedBy: withdrawal.approvedBy,
    processingAttemptBy: adminId,
  });
}

// Notifica admin que aprovou sobre conclus√£o
await notifyAdmin({
  adminId: withdrawal.approvedBy,
  type: 'WITHDRAWAL_COMPLETED',
  message: `Saque aprovado por voc√™ foi processado: ${txHash}`
});
```

---


---

## üìö Refer√™ncias

- [PRD v1.0](./PRD-MVP-v1.md)
- [Ethers.js Batch Transactions](https://docs.ethers.org/v6/api/providers/#Provider-sendTransaction)
- [Polygon Gas Optimization](https://docs.polygon.technology/docs/develop/network-details/gas-token/)

---

**√öltima atualiza√ß√£o:** 21/10/2025
**Pr√≥xima revis√£o:** Ap√≥s conclus√£o do v2.0
