
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum UserStatus {
  INACTIVE // Conta criada mas não ativada (sem depósito inicial)
  ACTIVE   // Conta ativada (depósito >= 100 EUR realizado)
  BLOCKED  // Conta bloqueada por admin
}

enum DepositAddressStatus {
  ACTIVE   // Endereço ativo e recebendo depósitos
  INACTIVE // Endereço desativado (admin)
}

enum TransactionType {
  CREDIT
  DEBIT
}

enum TransactionStatus {
  PENDING
  CONFIRMED
  SENT_TO_GLOBAL
  FAILED
}

enum WithdrawalStatus {
  PENDING_APPROVAL
  APPROVED
  PROCESSING
  COMPLETED
  REJECTED
  FAILED
}

enum NotificationType {
  WITHDRAWAL_APPROVED
  WITHDRAWAL_REJECTED
  WITHDRAWAL_COMPLETED
  WITHDRAWAL_FAILED
}

model User {
  id            String     @id @default(uuid())
  email         String     @unique
  name          String
  emailVerified Boolean    @default(false)
  image         String?
  role          String     @default("user") // "user" ou "admin"
  status        UserStatus @default(INACTIVE) // Inicia INATIVA até depósito de 100 EUR
  activatedAt   DateTime?  // Data de ativação da conta
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Better Auth relations
  sessions Session[]
  accounts Account[]

  // App relations
  depositAddresses        DepositAddress[]
  transactions            WalletTransaction[]
  balances                Balance[]
  withdrawals             Withdrawal[]
  withdrawalNotifications WithdrawalNotification[]

  @@map("users")
}

model Session {
  id        String   @id
  expiresAt DateTime
  token     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  ipAddress String?
  userAgent String?
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([token])
  @@map("session")
}

model Account {
  id                    String    @id
  accountId             String
  providerId            String
  userId                String
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  accessToken           String?
  refreshToken          String?
  idToken               String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?
  password              String?
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  @@map("account")
}

model Verification {
  id         String   @id
  identifier String
  value      String
  expiresAt  DateTime
  createdAt  DateTime @default(now())
  updatedAt  DateTime @default(now()) @updatedAt

  @@map("verification")
}

model DepositAddress {
  id             String                @id @default(uuid())
  userId         String                @unique // 1 endereço por usuário
  polygonAddress String                @unique
  privateKey     String // Encrypted (apenas plataforma tem acesso)
  status         DepositAddressStatus  @default(ACTIVE)
  createdAt      DateTime              @default(now())
  updatedAt      DateTime              @updatedAt

  user         User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions WalletTransaction[]

  @@map("deposit_addresses")
}

model WalletTransaction {
  id               String            @id @default(uuid())
  userId           String
  depositAddressId String
  type             TransactionType
  tokenSymbol      String // "USDC", "MATIC", "USDT", etc
  tokenAddress     String? // Contract address (null para MATIC)
  tokenDecimals    Int // 6 para USDC, 18 para MATIC
  amount           Decimal           @db.Decimal(20, 8) // Valor já convertido com decimais
  rawAmount        String // Valor raw da blockchain
  txHash           String            @unique // Hash da transação de depósito
  transferTxHash   String?           @unique // Hash da transferência para global
  status           TransactionStatus @default(PENDING)
  createdAt        DateTime          @default(now())

  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  depositAddress DepositAddress @relation(fields: [depositAddressId], references: [id], onDelete: Cascade)

  @@map("wallet_transactions")
}

model Balance {
  id               String   @id @default(uuid())
  userId           String
  tokenSymbol      String // "USDC", "MATIC", "USDT", etc
  tokenAddress     String? // Contract address (null para MATIC)
  availableBalance Decimal  @db.Decimal(20, 8) // Saldo disponível para saque
  lockedBalance    Decimal  @db.Decimal(20, 8) @default(0) // Saldo bloqueado (saques pendentes)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, tokenSymbol])
  @@index([userId])
  @@map("balances")
}

model GlobalWallet {
  id             String   @id @default(uuid())
  polygonAddress String   @unique
  privateKey     String // Criptografado
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  balances GlobalWalletBalance[]

  @@map("global_wallets")
}

model GlobalWalletBalance {
  id              String   @id @default(uuid())
  globalWalletId  String
  tokenSymbol     String // "USDC", "MATIC", "USDT", etc
  tokenAddress    String? // Contract address (null para MATIC)
  balance         Decimal  @db.Decimal(20, 8) // Saldo total da Global Wallet
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  globalWallet GlobalWallet @relation(fields: [globalWalletId], references: [id], onDelete: Cascade)

  @@unique([globalWalletId, tokenSymbol])
  @@index([globalWalletId])
  @@map("global_wallet_balances")
}

model Withdrawal {
  id                 String           @id @default(uuid())
  userId             String
  tokenSymbol        String
  tokenAddress       String?
  amount             Decimal          @db.Decimal(20, 8)
  destinationAddress String
  fee                Decimal          @db.Decimal(20, 8)
  status             WithdrawalStatus @default(PENDING_APPROVAL)
  txHash             String?          @unique
  approvedBy         String? // Admin userId
  approvedAt         DateTime?
  rejectedReason     String?
  processedAt        DateTime?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  user          User                     @relation(fields: [userId], references: [id], onDelete: Cascade)
  notifications WithdrawalNotification[]

  @@map("withdrawals")
}

model AdminLog {
  id        String   @id @default(uuid())
  adminId   String
  action    String // "APPROVE_WITHDRAWAL", "BATCH_TRANSFER", etc
  entityId  String? // ID do withdrawal, user, etc
  details   Json? // Detalhes adicionais
  createdAt DateTime @default(now())

  @@map("admin_logs")
}

model WithdrawalNotification {
  id           String           @id @default(uuid())
  userId       String
  withdrawalId String
  type         NotificationType
  title        String // "Saque Aprovado!"
  message      String // "Seu saque de 500 USDC foi aprovado pelo administrador"
  data         Json? // Dados adicionais (txHash, motivo rejeição, etc)
  read         Boolean          @default(false)
  createdAt    DateTime         @default(now())

  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  withdrawal Withdrawal @relation(fields: [withdrawalId], references: [id], onDelete: Cascade)

  @@index([userId, read]) // Para query de notificações não lidas
  @@map("withdrawal_notifications")
}
